module.exports = [
"[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].React; //# sourceMappingURL=react.js.map
}),
"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxRuntime; //# sourceMappingURL=react-jsx-runtime.js.map
}),
"[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// ES3 safe
var _undefined = void 0;
module.exports = function(value) {
    return value !== _undefined && value !== null;
};
}),
"[project]/node_modules/type/object/is.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isValue = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)");
// prettier-ignore
var possibleTypes = {
    "object": true,
    "function": true,
    "undefined": true
};
module.exports = function(value) {
    if (!isValue(value)) return false;
    return hasOwnProperty.call(possibleTypes, typeof value);
};
}),
"[project]/node_modules/type/prototype/is.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isObject = __turbopack_context__.r("[project]/node_modules/type/object/is.js [app-ssr] (ecmascript)");
module.exports = function(value) {
    if (!isObject(value)) return false;
    try {
        if (!value.constructor) return false;
        return value.constructor.prototype === value;
    } catch (error) {
        return false;
    }
};
}),
"[project]/node_modules/type/function/is.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isPrototype = __turbopack_context__.r("[project]/node_modules/type/prototype/is.js [app-ssr] (ecmascript)");
module.exports = function(value) {
    if (typeof value !== "function") return false;
    if (!hasOwnProperty.call(value, "length")) return false;
    try {
        if (typeof value.length !== "number") return false;
        if (typeof value.call !== "function") return false;
        if (typeof value.apply !== "function") return false;
    } catch (error) {
        return false;
    }
    return !isPrototype(value);
};
}),
"[project]/node_modules/type/plain-function/is.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isFunction = __turbopack_context__.r("[project]/node_modules/type/function/is.js [app-ssr] (ecmascript)");
var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
module.exports = function(value) {
    if (!isFunction(value)) return false;
    if (classRe.test(functionToString.call(value))) return false;
    return true;
};
}),
"[project]/node_modules/type/string/coerce.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isValue = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/type/object/is.js [app-ssr] (ecmascript)");
var objectToString = Object.prototype.toString;
module.exports = function(value) {
    if (!isValue(value)) return null;
    if (isObject(value)) {
        // Reject Object.prototype.toString coercion
        var valueToString = value.toString;
        if (typeof valueToString !== "function") return null;
        if (valueToString === objectToString) return null;
    // Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant
    // way to resolve its realm's Object.prototype.toString it's left as not addressed edge case
    }
    try {
        return "" + value; // Ensure implicit coercion
    } catch (error) {
        return null;
    }
};
}),
"[project]/node_modules/type/lib/safe-to-string.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(value) {
    try {
        return value.toString();
    } catch (error) {
        try {
            return String(value);
        } catch (error2) {
            return null;
        }
    }
};
}),
"[project]/node_modules/type/lib/to-short-string.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var safeToString = __turbopack_context__.r("[project]/node_modules/type/lib/safe-to-string.js [app-ssr] (ecmascript)");
var reNewLine = /[\n\r\u2028\u2029]/g;
module.exports = function(value) {
    var string = safeToString(value);
    if (string === null) return "<Non-coercible to string value>";
    // Trim if too long
    if (string.length > 100) string = string.slice(0, 99) + "â€¦";
    // Replace eventual new lines
    string = string.replace(reNewLine, function(char) {
        switch(char){
            case "\n":
                return "\\n";
            case "\r":
                return "\\r";
            case "\u2028":
                return "\\u2028";
            case "\u2029":
                return "\\u2029";
            /* istanbul ignore next */ default:
                throw new Error("Unexpected character");
        }
    });
    return string;
};
}),
"[project]/node_modules/type/lib/resolve-error-message.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var stringCoerce = __turbopack_context__.r("[project]/node_modules/type/string/coerce.js [app-ssr] (ecmascript)"), toShortString = __turbopack_context__.r("[project]/node_modules/type/lib/to-short-string.js [app-ssr] (ecmascript)");
module.exports = function(errorMessage, value, inputOptions) {
    if (inputOptions && inputOptions.errorMessage) {
        errorMessage = stringCoerce(inputOptions.errorMessage);
    }
    var valueInsertIndex = errorMessage.indexOf("%v");
    var valueToken = valueInsertIndex > -1 ? toShortString(value) : null;
    if (inputOptions && inputOptions.name) {
        var nameInsertIndex = errorMessage.indexOf("%n");
        if (nameInsertIndex > -1) {
            if (valueInsertIndex > -1) {
                var firstToken, secondToken, firstInsertIndex, secondInsertIndex;
                if (nameInsertIndex > valueInsertIndex) {
                    firstToken = valueToken;
                    firstInsertIndex = valueInsertIndex;
                    secondToken = inputOptions.name;
                    secondInsertIndex = nameInsertIndex;
                } else {
                    firstToken = inputOptions.name;
                    firstInsertIndex = nameInsertIndex;
                    secondToken = valueToken;
                    secondInsertIndex = valueInsertIndex;
                }
                return errorMessage.slice(0, firstInsertIndex) + firstToken + errorMessage.slice(firstInsertIndex + 2, secondInsertIndex) + secondToken + errorMessage.slice(secondInsertIndex + 2);
            }
            return errorMessage.slice(0, nameInsertIndex) + inputOptions.name + errorMessage.slice(nameInsertIndex + 2);
        }
    }
    if (valueInsertIndex > -1) {
        return errorMessage.slice(0, valueInsertIndex) + valueToken + errorMessage.slice(valueInsertIndex + 2);
    }
    return errorMessage;
};
}),
"[project]/node_modules/type/lib/resolve-exception.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isValue = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)"), resolveErrorMessage = __turbopack_context__.r("[project]/node_modules/type/lib/resolve-error-message.js [app-ssr] (ecmascript)");
module.exports = function(value, defaultMessage, inputOptions) {
    if (inputOptions && !isValue(value)) {
        if ("default" in inputOptions) return inputOptions["default"];
        if (inputOptions.isOptional) return null;
    }
    var ErrorConstructor = inputOptions && inputOptions.Error || TypeError;
    var error = new ErrorConstructor(resolveErrorMessage(defaultMessage, value, inputOptions));
    if (inputOptions && inputOptions.errorCode) error.code = inputOptions.errorCode;
    throw error;
};
}),
"[project]/node_modules/type/value/ensure.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolveException = __turbopack_context__.r("[project]/node_modules/type/lib/resolve-exception.js [app-ssr] (ecmascript)"), is = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)");
module.exports = function(value /*, options*/ ) {
    if (is(value)) return value;
    var options = arguments[1];
    var errorMessage = options && options.name ? "Expected a value for %n, received %v" : "Cannot use %v";
    return resolveException(value, errorMessage, options);
};
}),
"[project]/node_modules/type/plain-function/ensure.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolveException = __turbopack_context__.r("[project]/node_modules/type/lib/resolve-exception.js [app-ssr] (ecmascript)"), is = __turbopack_context__.r("[project]/node_modules/type/plain-function/is.js [app-ssr] (ecmascript)");
module.exports = function(value /*, options*/ ) {
    if (is(value)) return value;
    var options = arguments[1];
    var errorMessage = options && options.name ? "Expected a plain function for %n, received %v" : "%v is not a plain function";
    return resolveException(value, errorMessage, options);
};
}),
"[project]/node_modules/ext/global-this/is-implemented.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function() {
    if (typeof globalThis !== "object") return false;
    if (!globalThis) return false;
    return globalThis.Array === Array;
};
}),
"[project]/node_modules/ext/global-this/implementation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var naiveFallback = function() {
    if (typeof self === "object" && self) return self;
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    throw new Error("Unable to resolve global `this`");
};
module.exports = function() {
    if (this) return this;
    // Unexpected strict mode (may happen if e.g. bundled into ESM module)
    // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
    // In all ES5+ engines global object inherits from Object.prototype
    // (if you approached one that doesn't please report)
    try {
        Object.defineProperty(Object.prototype, "__global__", {
            get: function() {
                return this;
            },
            configurable: true
        });
    } catch (error) {
        // Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)
        return naiveFallback();
    }
    try {
        // Safari case (window.__global__ is resolved with global context, but __global__ does not)
        if (!__global__) return naiveFallback();
        return __global__;
    } finally{
        delete Object.prototype.__global__;
    }
}();
}),
"[project]/node_modules/ext/global-this/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/ext/global-this/is-implemented.js [app-ssr] (ecmascript)")() ? globalThis : __turbopack_context__.r("[project]/node_modules/ext/global-this/implementation.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/es6-symbol/is-implemented.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var global = __turbopack_context__.r("[project]/node_modules/ext/global-this/index.js [app-ssr] (ecmascript)"), validTypes = {
    object: true,
    symbol: true
};
module.exports = function() {
    var Symbol = global.Symbol;
    var symbol;
    if (typeof Symbol !== "function") return false;
    symbol = Symbol("test symbol");
    try {
        String(symbol);
    } catch (e) {
        return false;
    }
    // Return 'true' also for polyfills
    if (!validTypes[typeof Symbol.iterator]) return false;
    if (!validTypes[typeof Symbol.toPrimitive]) return false;
    if (!validTypes[typeof Symbol.toStringTag]) return false;
    return true;
};
}),
"[project]/node_modules/es6-symbol/is-symbol.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(value) {
    if (!value) return false;
    if (typeof value === "symbol") return true;
    if (!value.constructor) return false;
    if (value.constructor.name !== "Symbol") return false;
    return value[value.constructor.toStringTag] === "Symbol";
};
}),
"[project]/node_modules/es6-symbol/validate-symbol.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isSymbol = __turbopack_context__.r("[project]/node_modules/es6-symbol/is-symbol.js [app-ssr] (ecmascript)");
module.exports = function(value) {
    if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
    return value;
};
}),
"[project]/node_modules/es6-symbol/lib/private/generate-name.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)");
var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;
var created = create(null);
module.exports = function(desc) {
    var postfix = 0, name, ie11BugWorkaround;
    while(created[desc + (postfix || "")])++postfix;
    desc += postfix || "";
    created[desc] = true;
    name = "@@" + desc;
    defineProperty(objPrototype, name, d.gs(null, function(value) {
        // For IE11 issue see:
        // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
        //    ie11-broken-getters-on-dom-objects
        // https://github.com/medikoo/es6-symbol/issues/12
        if (ie11BugWorkaround) return;
        ie11BugWorkaround = true;
        defineProperty(this, name, d(value));
        ie11BugWorkaround = false;
    }));
    return name;
};
}),
"[project]/node_modules/es6-symbol/lib/private/setup/standard-symbols.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), NativeSymbol = __turbopack_context__.r("[project]/node_modules/ext/global-this/index.js [app-ssr] (ecmascript)").Symbol;
module.exports = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d("", NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")),
        isConcatSpreadable: d("", NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d("", NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")),
        toStringTag: d("", NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")),
        unscopables: d("", NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables"))
    });
};
}),
"[project]/node_modules/es6-symbol/lib/private/setup/symbol-registry.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), validateSymbol = __turbopack_context__.r("[project]/node_modules/es6-symbol/validate-symbol.js [app-ssr] (ecmascript)");
var registry = Object.create(null);
module.exports = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
            if (registry[key]) return registry[key];
            return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
            var key;
            validateSymbol(symbol);
            for(key in registry){
                if (registry[key] === symbol) return key;
            }
            return undefined;
        })
    });
};
}),
"[project]/node_modules/es6-symbol/polyfill.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// ES2015 Symbol polyfill for environments that do not (or partially) support it
var d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), validateSymbol = __turbopack_context__.r("[project]/node_modules/es6-symbol/validate-symbol.js [app-ssr] (ecmascript)"), NativeSymbol = __turbopack_context__.r("[project]/node_modules/ext/global-this/index.js [app-ssr] (ecmascript)").Symbol, generateName = __turbopack_context__.r("[project]/node_modules/es6-symbol/lib/private/generate-name.js [app-ssr] (ecmascript)"), setupStandardSymbols = __turbopack_context__.r("[project]/node_modules/es6-symbol/lib/private/setup/standard-symbols.js [app-ssr] (ecmascript)"), setupSymbolRegistry = __turbopack_context__.r("[project]/node_modules/es6-symbol/lib/private/setup/symbol-registry.js [app-ssr] (ecmascript)");
var create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty;
var SymbolPolyfill, HiddenSymbol, isNativeSafe;
if (typeof NativeSymbol === "function") {
    try {
        String(NativeSymbol());
        isNativeSafe = true;
    } catch (ignore) {}
} else {
    NativeSymbol = null;
}
// Internal constructor (not one exposed) for creating Symbol instances.
// This one is used to ensure that `someSymbol instanceof Symbol` always return false
HiddenSymbol = function Symbol(description) {
    if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
    return SymbolPolyfill(description);
};
// Exposed `Symbol` constructor
// (returns instances of HiddenSymbol)
module.exports = SymbolPolyfill = function Symbol(description) {
    var symbol;
    if (this instanceof Symbol) throw new TypeError("Symbol is not a constructor");
    if (isNativeSafe) return NativeSymbol(description);
    symbol = create(HiddenSymbol.prototype);
    description = description === undefined ? "" : String(description);
    return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
    });
};
setupStandardSymbols(SymbolPolyfill);
setupSymbolRegistry(SymbolPolyfill);
// Internal tweaks for real symbol producer
defineProperties(HiddenSymbol.prototype, {
    constructor: d(SymbolPolyfill),
    toString: d("", function() {
        return this.__name__;
    })
});
// Proper implementation of methods exposed on Symbol.prototype
// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
defineProperties(SymbolPolyfill.prototype, {
    toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
    }),
    valueOf: d(function() {
        return validateSymbol(this);
    })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d("", function() {
    var symbol = validateSymbol(this);
    if (typeof symbol === "symbol") return symbol;
    return symbol.toString();
}));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
// Note: It's important to define `toPrimitive` as last one, as some implementations
// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
// And that may invoke error in definition flow:
// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
}),
"[project]/node_modules/es6-symbol/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/es6-symbol/is-implemented.js [app-ssr] (ecmascript)")() ? __turbopack_context__.r("[project]/node_modules/ext/global-this/index.js [app-ssr] (ecmascript)").Symbol : __turbopack_context__.r("[project]/node_modules/es6-symbol/polyfill.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/d/auto-bind.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isValue = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)"), ensureValue = __turbopack_context__.r("[project]/node_modules/type/value/ensure.js [app-ssr] (ecmascript)"), ensurePlainFunction = __turbopack_context__.r("[project]/node_modules/type/plain-function/ensure.js [app-ssr] (ecmascript)"), copy = __turbopack_context__.r("[project]/node_modules/es5-ext/object/copy.js [app-ssr] (ecmascript)"), normalizeOptions = __turbopack_context__.r("[project]/node_modules/es5-ext/object/normalize-options.js [app-ssr] (ecmascript)"), map = __turbopack_context__.r("[project]/node_modules/es5-ext/object/map.js [app-ssr] (ecmascript)");
var bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty = Object.prototype.hasOwnProperty, define;
define = function(name, desc, options) {
    var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
    dgs = copy(desc);
    delete dgs.writable;
    delete dgs.value;
    dgs.get = function() {
        if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;
        desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
        defineProperty(this, name, desc);
        return this[name];
    };
    return dgs;
};
module.exports = function(props /*, options*/ ) {
    var options = normalizeOptions(arguments[1]);
    if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
    return map(props, function(desc, name) {
        return define(name, desc, options);
    });
};
}),
"[project]/node_modules/d/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isValue = __turbopack_context__.r("[project]/node_modules/type/value/is.js [app-ssr] (ecmascript)"), isPlainFunction = __turbopack_context__.r("[project]/node_modules/type/plain-function/is.js [app-ssr] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/es5-ext/object/assign/index.js [app-ssr] (ecmascript)"), normalizeOpts = __turbopack_context__.r("[project]/node_modules/es5-ext/object/normalize-options.js [app-ssr] (ecmascript)"), contains = __turbopack_context__.f({
    "es5-ext/string/": {
        id: ()=>"[project]/node_modules/es5-ext/string/index.js [app-ssr] (ecmascript)",
        module: ()=>__turbopack_context__.r("[project]/node_modules/es5-ext/string/index.js [app-ssr] (ecmascript)")
    },
    "es5-ext/string/#/contains": {
        id: ()=>"[project]/node_modules/es5-ext/string/#/contains/index.js [app-ssr] (ecmascript)",
        module: ()=>__turbopack_context__.r("[project]/node_modules/es5-ext/string/#/contains/index.js [app-ssr] (ecmascript)")
    }
})("es5-ext/string/#/contains");
var d = module.exports = function(dscr, value /*, options*/ ) {
    var c, e, w, options, desc;
    if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
    } else {
        options = arguments[2];
    }
    if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
        w = contains.call(dscr, "w");
    } else {
        c = w = true;
        e = false;
    }
    desc = {
        value: value,
        configurable: c,
        enumerable: e,
        writable: w
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
};
d.gs = function(dscr, get, set /*, options*/ ) {
    var c, e, options, desc;
    if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
    } else {
        options = arguments[3];
    }
    if (!isValue(get)) {
        get = undefined;
    } else if (!isPlainFunction(get)) {
        options = get;
        get = set = undefined;
    } else if (!isValue(set)) {
        set = undefined;
    } else if (!isPlainFunction(set)) {
        options = set;
        set = undefined;
    }
    if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
    } else {
        c = true;
        e = false;
    }
    desc = {
        get: get,
        set: set,
        configurable: c,
        enumerable: e
    };
    return !options ? desc : assign(normalizeOpts(options), desc);
};
}),
"[project]/node_modules/es6-iterator/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var clear = __turbopack_context__.r("[project]/node_modules/es5-ext/array/#/clear.js [app-ssr] (ecmascript)"), assign = __turbopack_context__.r("[project]/node_modules/es5-ext/object/assign/index.js [app-ssr] (ecmascript)"), callable = __turbopack_context__.r("[project]/node_modules/es5-ext/object/valid-callable.js [app-ssr] (ecmascript)"), value = __turbopack_context__.r("[project]/node_modules/es5-ext/object/valid-value.js [app-ssr] (ecmascript)"), d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), autoBind = __turbopack_context__.r("[project]/node_modules/d/auto-bind.js [app-ssr] (ecmascript)"), Symbol = __turbopack_context__.r("[project]/node_modules/es6-symbol/index.js [app-ssr] (ecmascript)");
var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
module.exports = Iterator = function(list, context) {
    if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
    defineProperties(this, {
        __list__: d("w", value(list)),
        __context__: d("w", context),
        __nextIndex__: d("w", 0)
    });
    if (!context) return;
    callable(context.on);
    context.on("_add", this._onAdd);
    context.on("_delete", this._onDelete);
    context.on("_clear", this._onClear);
};
// Internal %IteratorPrototype% doesn't expose its constructor
delete Iterator.prototype.constructor;
defineProperties(Iterator.prototype, assign({
    _next: d(function() {
        var i;
        if (!this.__list__) return undefined;
        if (this.__redo__) {
            i = this.__redo__.shift();
            if (i !== undefined) return i;
        }
        if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
        this._unBind();
        return undefined;
    }),
    next: d(function() {
        return this._createResult(this._next());
    }),
    _createResult: d(function(i) {
        if (i === undefined) return {
            done: true,
            value: undefined
        };
        return {
            done: false,
            value: this._resolve(i)
        };
    }),
    _resolve: d(function(i) {
        return this.__list__[i];
    }),
    _unBind: d(function() {
        this.__list__ = null;
        delete this.__redo__;
        if (!this.__context__) return;
        this.__context__.off("_add", this._onAdd);
        this.__context__.off("_delete", this._onDelete);
        this.__context__.off("_clear", this._onClear);
        this.__context__ = null;
    }),
    toString: d(function() {
        return "[object " + (this[Symbol.toStringTag] || "Object") + "]";
    })
}, autoBind({
    _onAdd: d(function(index) {
        if (index >= this.__nextIndex__) return;
        ++this.__nextIndex__;
        if (!this.__redo__) {
            defineProperty(this, "__redo__", d("c", [
                index
            ]));
            return;
        }
        this.__redo__.forEach(function(redo, i) {
            if (redo >= index) this.__redo__[i] = ++redo;
        }, this);
        this.__redo__.push(index);
    }),
    _onDelete: d(function(index) {
        var i;
        if (index >= this.__nextIndex__) return;
        --this.__nextIndex__;
        if (!this.__redo__) return;
        i = this.__redo__.indexOf(index);
        if (i !== -1) this.__redo__.splice(i, 1);
        this.__redo__.forEach(function(redo, j) {
            if (redo > index) this.__redo__[j] = --redo;
        }, this);
    }),
    _onClear: d(function() {
        if (this.__redo__) clear.call(this.__redo__);
        this.__nextIndex__ = 0;
    })
})));
defineProperty(Iterator.prototype, Symbol.iterator, d(function() {
    return this;
}));
}),
"[project]/node_modules/es6-iterator/string.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Thanks @mathiasbynens
// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols
var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/es5-ext/object/set-prototype-of/index.js [app-ssr] (ecmascript)"), d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), Symbol = __turbopack_context__.r("[project]/node_modules/es6-symbol/index.js [app-ssr] (ecmascript)"), Iterator = __turbopack_context__.r("[project]/node_modules/es6-iterator/index.js [app-ssr] (ecmascript)");
var defineProperty = Object.defineProperty, StringIterator;
StringIterator = module.exports = function(str) {
    if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
    str = String(str);
    Iterator.call(this, str);
    defineProperty(this, "__length__", d("", str.length));
};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);
// Internal %ArrayIteratorPrototype% doesn't expose its constructor
delete StringIterator.prototype.constructor;
StringIterator.prototype = Object.create(Iterator.prototype, {
    _next: d(function() {
        if (!this.__list__) return undefined;
        if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
        this._unBind();
        return undefined;
    }),
    _resolve: d(function(i) {
        var char = this.__list__[i], code;
        if (this.__nextIndex__ === this.__length__) return char;
        code = char.charCodeAt(0);
        if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];
        return char;
    })
});
defineProperty(StringIterator.prototype, Symbol.toStringTag, d("c", "String Iterator"));
}),
"[project]/node_modules/event-emitter/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var d = __turbopack_context__.r("[project]/node_modules/d/index.js [app-ssr] (ecmascript)"), callable = __turbopack_context__.r("[project]/node_modules/es5-ext/object/valid-callable.js [app-ssr] (ecmascript)"), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty = Object.prototype.hasOwnProperty, descriptor = {
    configurable: true,
    enumerable: false,
    writable: true
}, on, once, off, emit, methods, descriptors, base;
on = function(type, listener) {
    var data;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__')) {
        data = descriptor.value = create(null);
        defineProperty(this, '__ee__', descriptor);
        descriptor.value = null;
    } else {
        data = this.__ee__;
    }
    if (!data[type]) data[type] = listener;
    else if (typeof data[type] === 'object') data[type].push(listener);
    else data[type] = [
        data[type],
        listener
    ];
    return this;
};
once = function(type, listener) {
    var once, self;
    callable(listener);
    self = this;
    on.call(this, type, once = function() {
        off.call(self, type, once);
        apply.call(listener, this, arguments);
    });
    once.__eeOnceListener__ = listener;
    return this;
};
off = function(type, listener) {
    var data, listeners, candidate, i;
    callable(listener);
    if (!hasOwnProperty.call(this, '__ee__')) return this;
    data = this.__ee__;
    if (!data[type]) return this;
    listeners = data[type];
    if (typeof listeners === 'object') {
        for(i = 0; candidate = listeners[i]; ++i){
            if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
                else listeners.splice(i, 1);
            }
        }
    } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
            delete data[type];
        }
    }
    return this;
};
emit = function(type) {
    var i, l, listener, listeners, args;
    if (!hasOwnProperty.call(this, '__ee__')) return;
    listeners = this.__ee__[type];
    if (!listeners) return;
    if (typeof listeners === 'object') {
        l = arguments.length;
        args = new Array(l - 1);
        for(i = 1; i < l; ++i)args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for(i = 0; listener = listeners[i]; ++i){
            apply.call(listener, this, args);
        }
    } else {
        switch(arguments.length){
            case 1:
                call.call(listeners, this);
                break;
            case 2:
                call.call(listeners, this, arguments[1]);
                break;
            case 3:
                call.call(listeners, this, arguments[1], arguments[2]);
                break;
            default:
                l = arguments.length;
                args = new Array(l - 1);
                for(i = 1; i < l; ++i){
                    args[i - 1] = arguments[i];
                }
                apply.call(listeners, this, args);
        }
    }
};
methods = {
    on: on,
    once: once,
    off: off,
    emit: emit
};
descriptors = {
    on: d(on),
    once: d(once),
    off: d(off),
    emit: d(emit)
};
base = defineProperties({}, descriptors);
module.exports = exports = function(o) {
    return o == null ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;
}),
"[project]/node_modules/path-webpack/path.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

if (!process) {
    var process = {
        "cwd": function() {
            return '/';
        }
    };
}
function assertPath(path) {
    if (typeof path !== 'string') {
        throw new TypeError('Path must be a string. Received ' + path);
    }
}
// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
    var res = '';
    var lastSlash = -1;
    var dots = 0;
    var code;
    for(var i = 0; i <= path.length; ++i){
        if (i < path.length) code = path.charCodeAt(i);
        else if (code === 47 /*/*/ ) break;
        else code = 47 /*/*/ ;
        if (code === 47 /*/*/ ) {
            if (lastSlash === i - 1 || dots === 1) {
            // NOOP
            } else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/  || res.charCodeAt(res.length - 2) !== 46 /*.*/ ) {
                    if (res.length > 2) {
                        var start = res.length - 1;
                        var j = start;
                        for(; j >= 0; --j){
                            if (res.charCodeAt(j) === 47 /*/*/ ) break;
                        }
                        if (j !== start) {
                            if (j === -1) res = '';
                            else res = res.slice(0, j);
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    } else if (res.length === 2 || res.length === 1) {
                        res = '';
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += '/..';
                    else res = '..';
                }
            } else {
                if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 /*.*/  && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
    if (!dir) {
        return base;
    }
    if (dir === pathObject.root) {
        return dir + base;
    }
    return dir + sep + base;
}
var posix = {
    // path.resolve([from ...], to)
    resolve: function resolve() {
        var resolvedPath = '';
        var resolvedAbsolute = false;
        var cwd;
        for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
            var path;
            if (i >= 0) path = arguments[i];
            else {
                if (cwd === undefined) cwd = process.cwd();
                path = cwd;
            }
            assertPath(path);
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0) return '/' + resolvedPath;
            else return '/';
        } else if (resolvedPath.length > 0) {
            return resolvedPath;
        } else {
            return '.';
        }
    },
    normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var isAbsolute = path.charCodeAt(0) === 47 /*/*/ ;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/ ;
        // Normalize the path
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = '.';
        if (path.length > 0 && trailingSeparator) path += '/';
        if (isAbsolute) return '/' + path;
        return path;
    },
    isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47 /*/*/ ;
    },
    join: function join() {
        if (arguments.length === 0) return '.';
        var joined;
        for(var i = 0; i < arguments.length; ++i){
            var arg = arguments[i];
            assertPath(arg);
            if (arg.length > 0) {
                if (joined === undefined) joined = arg;
                else joined += '/' + arg;
            }
        }
        if (joined === undefined) return '.';
        return posix.normalize(joined);
    },
    relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return '';
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return '';
        // Trim any leading backslashes
        var fromStart = 1;
        for(; fromStart < from.length; ++fromStart){
            if (from.charCodeAt(fromStart) !== 47 /*/*/ ) break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        var toStart = 1;
        for(; toStart < to.length; ++toStart){
            if (to.charCodeAt(toStart) !== 47 /*/*/ ) break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for(; i <= length; ++i){
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === 47 /*/*/ ) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                    } else if (i === 0) {
                        // We get here if `from` is the root
                        // For example: from='/'; to='/foo'
                        return to.slice(toStart + i);
                    }
                } else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === 47 /*/*/ ) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                    } else if (i === 0) {
                        // We get here if `to` is the root.
                        // For example: from='/foo'; to='/'
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            var fromCode = from.charCodeAt(fromStart + i);
            var toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode) break;
            else if (fromCode === 47 /*/*/ ) lastCommonSep = i;
        }
        var out = '';
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
            if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/ ) {
                if (out.length === 0) out += '..';
                else out += '/..';
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === 47 /*/*/ ) ++toStart;
            return to.slice(toStart);
        }
    },
    _makeLong: function _makeLong(path) {
        return path;
    },
    dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return '.';
        var code = path.charCodeAt(0);
        var hasRoot = code === 47 /*/*/ ;
        var end = -1;
        var matchedSlash = true;
        for(var i = path.length - 1; i >= 1; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            } else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) return hasRoot ? '/' : '.';
        if (hasRoot && end === 1) return '//';
        return path.slice(0, end);
    },
    basename: function basename(path, ext) {
        if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path) return '';
            var extIdx = ext.length - 1;
            var firstNonSlashEnd = -1;
            for(i = path.length - 1; i >= 0; --i){
                var code = path.charCodeAt(i);
                if (code === 47 /*/*/ ) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        } else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end) end = firstNonSlashEnd;
            else if (end === -1) end = path.length;
            return path.slice(start, end);
        } else {
            for(i = path.length - 1; i >= 0; --i){
                if (path.charCodeAt(i) === 47 /*/*/ ) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                } else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1) return '';
            return path.slice(start, end);
        }
    },
    extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        for(var i = path.length - 1; i >= 0; --i){
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            return '';
        }
        return path.slice(startDot, end);
    },
    format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== 'object') {
            throw new TypeError('Parameter "pathObject" must be an object, not ' + typeof pathObject);
        }
        return _format('/', pathObject);
    },
    parse: function parse(path) {
        assertPath(path);
        var ret = {
            root: '',
            dir: '',
            base: '',
            ext: '',
            name: ''
        };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47 /*/*/ ;
        var start;
        if (isAbsolute) {
            ret.root = '/';
            start = 1;
        } else {
            start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        var preDotState = 0;
        // Get non-dir info
        for(; i >= start; --i){
            code = path.charCodeAt(i);
            if (code === 47 /*/*/ ) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === 46 /*.*/ ) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1) startDot = i;
                else if (preDotState !== 1) preDotState = 1;
            } else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                else ret.base = ret.name = path.slice(startPart, end);
            }
        } else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            } else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = '/';
        return ret;
    },
    sep: '/',
    delimiter: ':',
    posix: null
};
module.exports = posix;
}),
"[project]/node_modules/marks-pane/lib/svg.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createElement = createElement;
function createElement(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
exports.default = {
    createElement: createElement
};
}),
"[project]/node_modules/marks-pane/lib/events.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.proxyMouse = proxyMouse;
exports.clone = clone;
// import 'babelify/polyfill'; // needed for Object.assign
exports.default = {
    proxyMouse: proxyMouse
};
/**
 * Start proxying all mouse events that occur on the target node to each node in
 * a set of tracked nodes.
 *
 * The items in tracked do not strictly have to be DOM Nodes, but they do have
 * to have dispatchEvent, getBoundingClientRect, and getClientRects methods.
 *
 * @param target {Node} The node on which to listen for mouse events.
 * @param tracked {Node[]} A (possibly mutable) array of nodes to which to proxy
 *                         events.
 */ function proxyMouse(target, tracked) {
    function dispatch(e) {
        // We walk through the set of tracked elements in reverse order so that
        // events are sent to those most recently added first.
        //
        // This is the least surprising behaviour as it simulates the way the
        // browser would work if items added later were drawn "on top of"
        // earlier ones.
        for(var i = tracked.length - 1; i >= 0; i--){
            var t = tracked[i];
            var x = e.clientX;
            var y = e.clientY;
            if (e.touches && e.touches.length) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            }
            if (!contains(t, target, x, y)) {
                continue;
            }
            // The event targets this mark, so dispatch a cloned event:
            t.dispatchEvent(clone(e));
            break;
        }
    }
    if (target.nodeName === "iframe" || target.nodeName === "IFRAME") {
        try {
            // Try to get the contents if same domain
            this.target = target.contentDocument;
        } catch (err) {
            this.target = target;
        }
    } else {
        this.target = target;
    }
    var _arr = [
        'mouseup',
        'mousedown',
        'click',
        'touchstart'
    ];
    for(var _i = 0; _i < _arr.length; _i++){
        var ev = _arr[_i];
        this.target.addEventListener(ev, function(e) {
            return dispatch(e);
        }, false);
    }
}
/**
 * Clone a mouse event object.
 *
 * @param e {MouseEvent} A mouse event object to clone.
 * @returns {MouseEvent}
 */ function clone(e) {
    var opts = Object.assign({}, e, {
        bubbles: false
    });
    try {
        return new MouseEvent(e.type, opts);
    } catch (err) {
        // compat: webkit
        var copy = document.createEvent('MouseEvents');
        copy.initMouseEvent(e.type, false, opts.cancelable, opts.view, opts.detail, opts.screenX, opts.screenY, opts.clientX, opts.clientY, opts.ctrlKey, opts.altKey, opts.shiftKey, opts.metaKey, opts.button, opts.relatedTarget);
        return copy;
    }
}
/**
 * Check if the item contains the point denoted by the passed coordinates
 * @param item {Object} An object with getBoundingClientRect and getClientRects
 *                      methods.
 * @param x {Number}
 * @param y {Number}
 * @returns {Boolean}
 */ function contains(item, target, x, y) {
    // offset
    var offset = target.getBoundingClientRect();
    function rectContains(r, x, y) {
        var top = r.top - offset.top;
        var left = r.left - offset.left;
        var bottom = top + r.height;
        var right = left + r.width;
        return top <= y && left <= x && bottom > y && right > x;
    }
    // Check overall bounding box first
    var rect = item.getBoundingClientRect();
    if (!rectContains(rect, x, y)) {
        return false;
    }
    // Then continue to check each child rect
    var rects = item.getClientRects();
    for(var i = 0, len = rects.length; i < len; i++){
        if (rectContains(rects[i], x, y)) {
            return true;
        }
    }
    return false;
}
}),
"[project]/node_modules/marks-pane/lib/marks.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Underline = exports.Highlight = exports.Mark = exports.Pane = undefined;
var _get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
            return undefined;
        } else {
            return get(parent, property, receiver);
        }
    } else if ("value" in desc) {
        return desc.value;
    } else {
        var getter = desc.get;
        if (getter === undefined) {
            return undefined;
        }
        return getter.call(receiver);
    }
};
var _createClass = function() {
    function defineProperties(target, props) {
        for(var i = 0; i < props.length; i++){
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();
var _svg = __turbopack_context__.r("[project]/node_modules/marks-pane/lib/svg.js [app-ssr] (ecmascript)");
var _svg2 = _interopRequireDefault(_svg);
var _events = __turbopack_context__.r("[project]/node_modules/marks-pane/lib/events.js [app-ssr] (ecmascript)");
var _events2 = _interopRequireDefault(_events);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Pane = exports.Pane = function() {
    function Pane(target) {
        var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;
        _classCallCheck(this, Pane);
        this.target = target;
        this.element = _svg2.default.createElement('svg');
        this.marks = [];
        // Match the coordinates of the target element
        this.element.style.position = 'absolute';
        // Disable pointer events
        this.element.setAttribute('pointer-events', 'none');
        // Set up mouse event proxying between the target element and the marks
        _events2.default.proxyMouse(this.target, this.marks);
        this.container = container;
        this.container.appendChild(this.element);
        this.render();
    }
    _createClass(Pane, [
        {
            key: 'addMark',
            value: function addMark(mark) {
                var g = _svg2.default.createElement('g');
                this.element.appendChild(g);
                mark.bind(g, this.container);
                this.marks.push(mark);
                mark.render();
                return mark;
            }
        },
        {
            key: 'removeMark',
            value: function removeMark(mark) {
                var idx = this.marks.indexOf(mark);
                if (idx === -1) {
                    return;
                }
                var el = mark.unbind();
                this.element.removeChild(el);
                this.marks.splice(idx, 1);
            }
        },
        {
            key: 'render',
            value: function render() {
                setCoords(this.element, coords(this.target, this.container));
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;
                try {
                    for(var _iterator = this.marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var m = _step.value;
                        m.render();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            }
        }
    ]);
    return Pane;
}();
var Mark = exports.Mark = function() {
    function Mark() {
        _classCallCheck(this, Mark);
        this.element = null;
    }
    _createClass(Mark, [
        {
            key: 'bind',
            value: function bind(element, container) {
                this.element = element;
                this.container = container;
            }
        },
        {
            key: 'unbind',
            value: function unbind() {
                var el = this.element;
                this.element = null;
                return el;
            }
        },
        {
            key: 'render',
            value: function render() {}
        },
        {
            key: 'dispatchEvent',
            value: function dispatchEvent(e) {
                if (!this.element) return;
                this.element.dispatchEvent(e);
            }
        },
        {
            key: 'getBoundingClientRect',
            value: function getBoundingClientRect() {
                return this.element.getBoundingClientRect();
            }
        },
        {
            key: 'getClientRects',
            value: function getClientRects() {
                var rects = [];
                var el = this.element.firstChild;
                while(el){
                    rects.push(el.getBoundingClientRect());
                    el = el.nextSibling;
                }
                return rects;
            }
        },
        {
            key: 'filteredRanges',
            value: function filteredRanges() {
                var rects = Array.from(this.range.getClientRects());
                // De-duplicate the boxes
                return rects.filter(function(box) {
                    for(var i = 0; i < rects.length; i++){
                        if (rects[i] === box) {
                            return true;
                        }
                        var contained = contains(rects[i], box);
                        if (contained) {
                            return false;
                        }
                    }
                    return true;
                });
            }
        }
    ]);
    return Mark;
}();
var Highlight = exports.Highlight = function(_Mark) {
    _inherits(Highlight, _Mark);
    function Highlight(range, className, data, attributes) {
        _classCallCheck(this, Highlight);
        var _this = _possibleConstructorReturn(this, (Highlight.__proto__ || Object.getPrototypeOf(Highlight)).call(this));
        _this.range = range;
        _this.className = className;
        _this.data = data || {};
        _this.attributes = attributes || {};
        return _this;
    }
    _createClass(Highlight, [
        {
            key: 'bind',
            value: function bind(element, container) {
                _get(Highlight.prototype.__proto__ || Object.getPrototypeOf(Highlight.prototype), 'bind', this).call(this, element, container);
                for(var attr in this.data){
                    if (this.data.hasOwnProperty(attr)) {
                        this.element.dataset[attr] = this.data[attr];
                    }
                }
                for(var attr in this.attributes){
                    if (this.attributes.hasOwnProperty(attr)) {
                        this.element.setAttribute(attr, this.attributes[attr]);
                    }
                }
                if (this.className) {
                    this.element.classList.add(this.className);
                }
            }
        },
        {
            key: 'render',
            value: function render() {
                // Empty element
                while(this.element.firstChild){
                    this.element.removeChild(this.element.firstChild);
                }
                var docFrag = this.element.ownerDocument.createDocumentFragment();
                var filtered = this.filteredRanges();
                var offset = this.element.getBoundingClientRect();
                var container = this.container.getBoundingClientRect();
                for(var i = 0, len = filtered.length; i < len; i++){
                    var r = filtered[i];
                    var el = _svg2.default.createElement('rect');
                    el.setAttribute('x', r.left - offset.left + container.left);
                    el.setAttribute('y', r.top - offset.top + container.top);
                    el.setAttribute('height', r.height);
                    el.setAttribute('width', r.width);
                    docFrag.appendChild(el);
                }
                this.element.appendChild(docFrag);
            }
        }
    ]);
    return Highlight;
}(Mark);
var Underline = exports.Underline = function(_Highlight) {
    _inherits(Underline, _Highlight);
    function Underline(range, className, data, attributes) {
        _classCallCheck(this, Underline);
        return _possibleConstructorReturn(this, (Underline.__proto__ || Object.getPrototypeOf(Underline)).call(this, range, className, data, attributes));
    }
    _createClass(Underline, [
        {
            key: 'render',
            value: function render() {
                // Empty element
                while(this.element.firstChild){
                    this.element.removeChild(this.element.firstChild);
                }
                var docFrag = this.element.ownerDocument.createDocumentFragment();
                var filtered = this.filteredRanges();
                var offset = this.element.getBoundingClientRect();
                var container = this.container.getBoundingClientRect();
                for(var i = 0, len = filtered.length; i < len; i++){
                    var r = filtered[i];
                    var rect = _svg2.default.createElement('rect');
                    rect.setAttribute('x', r.left - offset.left + container.left);
                    rect.setAttribute('y', r.top - offset.top + container.top);
                    rect.setAttribute('height', r.height);
                    rect.setAttribute('width', r.width);
                    rect.setAttribute('fill', 'none');
                    var line = _svg2.default.createElement('line');
                    line.setAttribute('x1', r.left - offset.left + container.left);
                    line.setAttribute('x2', r.left - offset.left + container.left + r.width);
                    line.setAttribute('y1', r.top - offset.top + container.top + r.height - 1);
                    line.setAttribute('y2', r.top - offset.top + container.top + r.height - 1);
                    line.setAttribute('stroke-width', 1);
                    line.setAttribute('stroke', 'black'); //TODO: match text color?
                    line.setAttribute('stroke-linecap', 'square');
                    docFrag.appendChild(rect);
                    docFrag.appendChild(line);
                }
                this.element.appendChild(docFrag);
            }
        }
    ]);
    return Underline;
}(Highlight);
function coords(el, container) {
    var offset = container.getBoundingClientRect();
    var rect = el.getBoundingClientRect();
    return {
        top: rect.top - offset.top,
        left: rect.left - offset.left,
        height: el.scrollHeight,
        width: el.scrollWidth
    };
}
function setCoords(el, coords) {
    el.style.setProperty('top', coords.top + 'px', 'important');
    el.style.setProperty('left', coords.left + 'px', 'important');
    el.style.setProperty('height', coords.height + 'px', 'important');
    el.style.setProperty('width', coords.width + 'px', 'important');
}
function contains(rect1, rect2) {
    return rect2.right <= rect1.right && rect2.left >= rect1.left && rect2.top >= rect1.top && rect2.bottom <= rect1.bottom;
}
}),
"[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;
}),
"[project]/node_modules/lodash/_freeGlobal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/** Detect free variable `global` from Node.js. */ var freeGlobal = ("TURBOPACK compile-time value", "object") == 'object' && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.Object === Object && /*TURBOPACK member replacement*/ __turbopack_context__.g;
module.exports = freeGlobal;
}),
"[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var freeGlobal = __turbopack_context__.r("[project]/node_modules/lodash/_freeGlobal.js [app-ssr] (ecmascript)");
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;
}),
"[project]/node_modules/lodash/now.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
module.exports = now;
}),
"[project]/node_modules/lodash/_trimmedEndIndex.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/** Used to match a single whitespace character. */ var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */ function trimmedEndIndex(string) {
    var index = string.length;
    while(index-- && reWhitespace.test(string.charAt(index))){}
    return index;
}
module.exports = trimmedEndIndex;
}),
"[project]/node_modules/lodash/_baseTrim.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var trimmedEndIndex = __turbopack_context__.r("[project]/node_modules/lodash/_trimmedEndIndex.js [app-ssr] (ecmascript)");
/** Used to match leading whitespace. */ var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */ function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}
module.exports = baseTrim;
}),
"[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/** Built-in value references. */ var Symbol = root.Symbol;
module.exports = Symbol;
}),
"[project]/node_modules/lodash/_getRawTag.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Symbol = __turbopack_context__.r("[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
module.exports = getRawTag;
}),
"[project]/node_modules/lodash/_objectToString.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;
}),
"[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Symbol = __turbopack_context__.r("[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)"), getRawTag = __turbopack_context__.r("[project]/node_modules/lodash/_getRawTag.js [app-ssr] (ecmascript)"), objectToString = __turbopack_context__.r("[project]/node_modules/lodash/_objectToString.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;
}),
"[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
module.exports = isObjectLike;
}),
"[project]/node_modules/lodash/isSymbol.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var baseGetTag = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
module.exports = isSymbol;
}),
"[project]/node_modules/lodash/toNumber.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var baseTrim = __turbopack_context__.r("[project]/node_modules/lodash/_baseTrim.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)"), isSymbol = __turbopack_context__.r("[project]/node_modules/lodash/isSymbol.js [app-ssr] (ecmascript)");
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = toNumber;
}),
"[project]/node_modules/lodash/debounce.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)"), now = __turbopack_context__.r("[project]/node_modules/lodash/now.js [app-ssr] (ecmascript)"), toNumber = __turbopack_context__.r("[project]/node_modules/lodash/toNumber.js [app-ssr] (ecmascript)");
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
module.exports = debounce;
}),
"[project]/node_modules/lodash/throttle.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

var debounce = __turbopack_context__.r("[project]/node_modules/lodash/debounce.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)");
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */ function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
    });
}
module.exports = throttle;
}),
"[project]/node_modules/react-swipeable/es/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DOWN",
    ()=>DOWN,
    "LEFT",
    ()=>LEFT,
    "RIGHT",
    ()=>RIGHT,
    "UP",
    ()=>UP,
    "useSwipeable",
    ()=>useSwipeable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
;
const LEFT = "Left";
const RIGHT = "Right";
const UP = "Up";
const DOWN = "Down";
/* global document */ const defaultProps = {
    delta: 10,
    preventScrollOnSwipe: false,
    rotationAngle: 0,
    trackMouse: false,
    trackTouch: true,
    swipeDuration: Infinity,
    touchEventOptions: {
        passive: true
    }
};
const initialState = {
    first: true,
    initial: [
        0,
        0
    ],
    start: 0,
    swiping: false,
    xy: [
        0,
        0
    ]
};
const mouseMove = "mousemove";
const mouseUp = "mouseup";
const touchEnd = "touchend";
const touchMove = "touchmove";
const touchStart = "touchstart";
function getDirection(absX, absY, deltaX, deltaY) {
    if (absX > absY) {
        if (deltaX > 0) {
            return RIGHT;
        }
        return LEFT;
    } else if (deltaY > 0) {
        return DOWN;
    }
    return UP;
}
function rotateXYByAngle(pos, angle) {
    if (angle === 0) return pos;
    const angleInRadians = Math.PI / 180 * angle;
    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
    return [
        x,
        y
    ];
}
function getHandlers(set, handlerProps) {
    const onStart = (event)=>{
        const isTouch = "touches" in event;
        // if more than a single touch don't track, for now...
        if (isTouch && event.touches.length > 1) return;
        set((state, props)=>{
            // setup mouse listeners on document to track swipe since swipe can leave container
            if (props.trackMouse && !isTouch) {
                document.addEventListener(mouseMove, onMove);
                document.addEventListener(mouseUp, onUp);
            }
            const { clientX, clientY } = isTouch ? event.touches[0] : event;
            const xy = rotateXYByAngle([
                clientX,
                clientY
            ], props.rotationAngle);
            props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({
                event
            });
            return Object.assign(Object.assign(Object.assign({}, state), initialState), {
                initial: xy.slice(),
                xy,
                start: event.timeStamp || 0
            });
        });
    };
    const onMove = (event)=>{
        set((state, props)=>{
            const isTouch = "touches" in event;
            // Discount a swipe if additional touches are present after
            // a swipe has started.
            if (isTouch && event.touches.length > 1) {
                return state;
            }
            // if swipe has exceeded duration stop tracking
            if (event.timeStamp - state.start > props.swipeDuration) {
                return state.swiping ? Object.assign(Object.assign({}, state), {
                    swiping: false
                }) : state;
            }
            const { clientX, clientY } = isTouch ? event.touches[0] : event;
            const [x, y] = rotateXYByAngle([
                clientX,
                clientY
            ], props.rotationAngle);
            const deltaX = x - state.xy[0];
            const deltaY = y - state.xy[1];
            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);
            const time = (event.timeStamp || 0) - state.start;
            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);
            const vxvy = [
                deltaX / (time || 1),
                deltaY / (time || 1)
            ];
            const dir = getDirection(absX, absY, deltaX, deltaY);
            // if swipe is under delta and we have not started to track a swipe: skip update
            const delta = typeof props.delta === "number" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;
            if (absX < delta && absY < delta && !state.swiping) return state;
            const eventData = {
                absX,
                absY,
                deltaX,
                deltaY,
                dir,
                event,
                first: state.first,
                initial: state.initial,
                velocity,
                vxvy
            };
            // call onSwipeStart if present and is first swipe event
            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);
            // call onSwiping if present
            props.onSwiping && props.onSwiping(eventData);
            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)
            // so we can call preventDefault if needed
            let cancelablePageSwipe = false;
            if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {
                cancelablePageSwipe = true;
            }
            if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {
                event.preventDefault();
            }
            return Object.assign(Object.assign({}, state), {
                // first is now always false
                first: false,
                eventData,
                swiping: true
            });
        });
    };
    const onEnd = (event)=>{
        set((state, props)=>{
            let eventData;
            if (state.swiping && state.eventData) {
                // if swipe is less than duration fire swiped callbacks
                if (event.timeStamp - state.start < props.swipeDuration) {
                    eventData = Object.assign(Object.assign({}, state.eventData), {
                        event
                    });
                    props.onSwiped && props.onSwiped(eventData);
                    const onSwipedDir = props[`onSwiped${eventData.dir}`];
                    onSwipedDir && onSwipedDir(eventData);
                }
            } else {
                props.onTap && props.onTap({
                    event
                });
            }
            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({
                event
            });
            return Object.assign(Object.assign(Object.assign({}, state), initialState), {
                eventData
            });
        });
    };
    const cleanUpMouse = ()=>{
        // safe to just call removeEventListener
        document.removeEventListener(mouseMove, onMove);
        document.removeEventListener(mouseUp, onUp);
    };
    const onUp = (e)=>{
        cleanUpMouse();
        onEnd(e);
    };
    /**
     * The value of passive on touchMove depends on `preventScrollOnSwipe`:
     * - true => { passive: false }
     * - false => { passive: true } // Default
     *
     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.
     *
     * props.touchEventOptions can also be set for all touch event listeners,
     * but for `touchmove` specifically when `preventScrollOnSwipe` it will
     * supersede and force passive to false.
     *
     */ const attachTouch = (el, props)=>{
        let cleanup = ()=>{};
        if (el && el.addEventListener) {
            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);
            // attach touch event listeners and handlers
            const tls = [
                [
                    touchStart,
                    onStart,
                    baseOptions
                ],
                // preventScrollOnSwipe option supersedes touchEventOptions.passive
                [
                    touchMove,
                    onMove,
                    Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {
                        passive: false
                    } : {})
                ],
                [
                    touchEnd,
                    onEnd,
                    baseOptions
                ]
            ];
            tls.forEach(([e, h, o])=>el.addEventListener(e, h, o));
            // return properly scoped cleanup method for removing listeners, options not required
            cleanup = ()=>tls.forEach(([e, h])=>el.removeEventListener(e, h));
        }
        return cleanup;
    };
    const onRef = (el)=>{
        // "inline" ref functions are called twice on render, once with null then again with DOM element
        // ignore null here
        if (el === null) return;
        set((state, props)=>{
            // if the same DOM el as previous just return state
            if (state.el === el) return state;
            const addState = {};
            // if new DOM el clean up old DOM and reset cleanUpTouch
            if (state.el && state.el !== el && state.cleanUpTouch) {
                state.cleanUpTouch();
                addState.cleanUpTouch = void 0;
            }
            // only attach if we want to track touch
            if (props.trackTouch && el) {
                addState.cleanUpTouch = attachTouch(el, props);
            }
            // store event attached DOM el for comparison, clean up, and re-attachment
            return Object.assign(Object.assign(Object.assign({}, state), {
                el
            }), addState);
        });
    };
    // set ref callback to attach touch event listeners
    const output = {
        ref: onRef
    };
    // if track mouse attach mouse down listener
    if (handlerProps.trackMouse) {
        output.onMouseDown = onStart;
    }
    return [
        output,
        attachTouch
    ];
}
function updateTransientState(state, props, previousProps, attachTouch) {
    // if trackTouch is off or there is no el, then remove handlers if necessary and exit
    if (!props.trackTouch || !state.el) {
        if (state.cleanUpTouch) {
            state.cleanUpTouch();
        }
        return Object.assign(Object.assign({}, state), {
            cleanUpTouch: undefined
        });
    }
    // trackTouch is on, so if there are no handlers attached, attach them and exit
    if (!state.cleanUpTouch) {
        return Object.assign(Object.assign({}, state), {
            cleanUpTouch: attachTouch(state.el, props)
        });
    }
    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,
    // remove and reattach handlers (this is required to update the passive option when attaching
    // the handlers)
    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {
        state.cleanUpTouch();
        return Object.assign(Object.assign({}, state), {
            cleanUpTouch: attachTouch(state.el, props)
        });
    }
    return state;
}
function useSwipeable(options) {
    const { trackMouse } = options;
    const transientState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"](Object.assign({}, initialState));
    const transientProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"](Object.assign({}, defaultProps));
    // track previous rendered props
    const previousProps = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useRef"](Object.assign({}, transientProps.current));
    previousProps.current = Object.assign({}, transientProps.current);
    // update current render props & defaults
    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);
    // Force defaults for config properties
    let defaultKey;
    for(defaultKey in defaultProps){
        if (transientProps.current[defaultKey] === void 0) {
            transientProps.current[defaultKey] = defaultProps[defaultKey];
        }
    }
    const [handlers, attachTouch] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useMemo"](()=>getHandlers((stateSetter)=>transientState.current = stateSetter(transientState.current, transientProps.current), {
            trackMouse
        }), [
        trackMouse
    ]);
    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);
    return handlers;
}
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/react-reader/dist/react-reader.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EpubView",
    ()=>EpubView,
    "EpubViewStyle",
    ()=>EpubViewStyle,
    "ReactReader",
    ()=>ReactReader,
    "ReactReaderStyle",
    ()=>ReactReaderStyle
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$epubjs$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/epubjs/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$swipeable$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-swipeable/es/index.js [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
;
;
;
;
const EpubViewStyle = {
    viewHolder: {
        position: "relative",
        height: "100%",
        width: "100%"
    },
    view: {
        height: "100%"
    }
};
class EpubView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Component"] {
    constructor(props){
        super(props);
        __publicField(this, "state", {
            isLoaded: false,
            isError: false,
            toc: []
        });
        __publicField(this, "viewerRef", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createRef());
        __publicField(this, "location");
        __publicField(this, "book");
        __publicField(this, "rendition");
        __publicField(this, "prevPage");
        __publicField(this, "nextPage");
        __publicField(this, "onLocationChange", (loc)=>{
            const { location, locationChanged } = this.props;
            const newLocation = `${loc.start}`;
            if (location !== newLocation) {
                this.location = newLocation;
                locationChanged && locationChanged(newLocation);
            }
        });
        __publicField(this, "handleKeyPress", (event)=>{
            if (!this.props.handleKeyPress) {
                if (event.key === "ArrowRight" && this.nextPage) {
                    this.nextPage();
                }
                if (event.key === "ArrowLeft" && this.prevPage) {
                    this.prevPage();
                }
            }
        });
        this.location = props.location;
        this.book = this.rendition = this.prevPage = this.nextPage = void 0;
    }
    componentDidMount() {
        this.initBook();
        document.addEventListener("keyup", this.handleKeyPress, false);
    }
    initBook() {
        const { url, tocChanged, epubInitOptions } = this.props;
        if (this.book) {
            this.book.destroy();
        }
        this.book = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$epubjs$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(url, epubInitOptions);
        this.book.on("openFailed", (error)=>{
            this.setState({
                isError: true
            });
        });
        this.book.loaded.navigation.then(({ toc })=>{
            this.setState({
                isLoaded: true,
                isError: false,
                toc
            }, ()=>{
                tocChanged && tocChanged(toc);
                this.initReader();
            });
        });
    }
    componentWillUnmount() {
        if (this.book) {
            this.book.destroy();
        }
        this.book = this.rendition = this.prevPage = this.nextPage = void 0;
        document.removeEventListener("keyup", this.handleKeyPress, false);
    }
    shouldComponentUpdate(nextProps) {
        return !this.state.isLoaded || nextProps.location !== this.props.location || nextProps.url !== this.props.url;
    }
    componentDidUpdate(prevProps) {
        var _a;
        if (prevProps.location !== this.props.location && this.location !== this.props.location) {
            (_a = this.rendition) == null ? void 0 : _a.display(this.props.location + "");
        }
        if (prevProps.url !== this.props.url) {
            this.initBook();
        }
    }
    initReader() {
        const { toc } = this.state;
        const { location, epubOptions, getRendition } = this.props;
        if (this.viewerRef.current) {
            const node = this.viewerRef.current;
            if (this.book) {
                const rendition = this.book.renderTo(node, {
                    width: "100%",
                    height: "100%",
                    ...epubOptions
                });
                this.rendition = rendition;
                this.prevPage = ()=>{
                    rendition.prev();
                };
                this.nextPage = ()=>{
                    rendition.next();
                };
                this.registerEvents();
                getRendition && getRendition(rendition);
                if (typeof location === "string" || typeof location === "number") {
                    rendition.display(location + "");
                } else if (toc.length > 0 && toc[0].href) {
                    rendition.display(toc[0].href);
                } else {
                    rendition.display();
                }
            }
        }
    }
    registerEvents() {
        const { handleKeyPress, handleTextSelected } = this.props;
        if (this.rendition) {
            this.rendition.on("locationChanged", this.onLocationChange);
            this.rendition.on("keyup", handleKeyPress || this.handleKeyPress);
            if (handleTextSelected) {
                this.rendition.on("selected", handleTextSelected);
            }
        }
    }
    renderBook() {
        const { epubViewStyles = EpubViewStyle } = this.props;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
            ref: this.viewerRef,
            style: epubViewStyles.view
        });
    }
    render() {
        const { isLoaded, isError } = this.state;
        const { loadingView = null, errorView = null, epubViewStyles = EpubViewStyle } = this.props;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
            style: epubViewStyles.viewHolder,
            children: [
                isLoaded && this.renderBook(),
                !isLoaded && !isError && loadingView,
                !isLoaded && isError && errorView
            ]
        });
    }
}
const ReactReaderStyle = {
    container: {
        overflow: "hidden",
        position: "relative",
        height: "100%"
    },
    readerArea: {
        position: "relative",
        zIndex: 1,
        height: "100%",
        width: "100%",
        backgroundColor: "#fff",
        transition: "all .3s ease"
    },
    containerExpanded: {
        transform: "translateX(256px)"
    },
    titleArea: {
        position: "absolute",
        top: 20,
        left: 50,
        right: 50,
        textAlign: "center",
        color: "#999"
    },
    reader: {
        position: "absolute",
        top: 50,
        left: 50,
        bottom: 20,
        right: 50
    },
    swipeWrapper: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        zIndex: 200
    },
    prev: {
        left: 1
    },
    next: {
        right: 1
    },
    arrow: {
        outline: "none",
        border: "none",
        background: "none",
        position: "absolute",
        top: "50%",
        marginTop: -32,
        fontSize: 64,
        padding: "0 10px",
        color: "#E2E2E2",
        fontFamily: "arial, sans-serif",
        cursor: "pointer",
        userSelect: "none",
        appearance: "none",
        fontWeight: "normal"
    },
    arrowHover: {
        color: "#777"
    },
    toc: {},
    tocBackground: {
        position: "absolute",
        left: 256,
        top: 0,
        bottom: 0,
        right: 0,
        zIndex: 1
    },
    tocArea: {
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 0,
        width: 256,
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        background: "#f2f2f2",
        padding: "10px 0"
    },
    tocAreaButton: {
        userSelect: "none",
        appearance: "none",
        background: "none",
        border: "none",
        display: "block",
        fontFamily: "sans-serif",
        width: "100%",
        fontSize: ".9em",
        textAlign: "left",
        padding: ".9em 1em",
        borderBottom: "1px solid #ddd",
        color: "#aaa",
        boxSizing: "border-box",
        outline: "none",
        cursor: "pointer"
    },
    tocButton: {
        background: "none",
        border: "none",
        width: 32,
        height: 32,
        position: "absolute",
        top: 10,
        left: 10,
        borderRadius: 2,
        outline: "none",
        cursor: "pointer"
    },
    tocButtonExpanded: {
        background: "#f2f2f2"
    },
    tocButtonBar: {
        position: "absolute",
        width: "60%",
        background: "#ccc",
        height: 2,
        left: "50%",
        margin: "-1px -30%",
        top: "50%",
        transition: "all .5s ease"
    },
    tocButtonBarTop: {
        top: "35%"
    },
    tocButtonBottom: {
        top: "66%"
    },
    loadingView: {
        position: "absolute",
        top: "50%",
        left: "10%",
        right: "10%",
        color: "#ccc",
        textAlign: "center",
        marginTop: "-.5em"
    },
    errorView: {
        position: "absolute",
        top: "50%",
        left: "10%",
        right: "10%",
        color: "#c00",
        textAlign: "center",
        marginTop: "-.5em"
    }
};
const SwipeWrapper = ({ children, swipeProps })=>{
    const handlers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$swipeable$2f$es$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["useSwipeable"])(swipeProps);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
        style: {
            height: "100%"
        },
        ...handlers,
        children
    });
};
const TocItem = ({ data, setLocation, styles })=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("button", {
                onClick: ()=>setLocation(data.href),
                style: styles,
                children: data.label
            }),
            data.subitems && data.subitems.length > 0 && /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                style: {
                    paddingLeft: 10
                },
                children: data.subitems.map((item, i)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(TocItem, {
                        data: item,
                        styles,
                        setLocation
                    }, i))
            })
        ]
    });
class ReactReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PureComponent"] {
    constructor(props){
        super(props);
        __publicField(this, "state", {
            isLoaded: false,
            expandedToc: false,
            toc: []
        });
        __publicField(this, "readerRef", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].createRef());
        __publicField(this, "toggleToc", ()=>{
            this.setState({
                expandedToc: !this.state.expandedToc
            });
        });
        __publicField(this, "next", ()=>{
            const node = this.readerRef.current;
            if (node && node.nextPage) {
                node.nextPage();
            }
        });
        __publicField(this, "prev", ()=>{
            const node = this.readerRef.current;
            if (node && node.prevPage) {
                node.prevPage();
            }
        });
        __publicField(this, "onTocChange", (toc)=>{
            const { tocChanged } = this.props;
            this.setState({
                toc
            }, ()=>tocChanged && tocChanged(toc));
        });
        __publicField(this, "setLocation", (loc)=>{
            const { locationChanged } = this.props;
            this.setState({
                expandedToc: false
            }, ()=>locationChanged && locationChanged(loc));
        });
        // Changing Page based on direction of scroll
        __publicField(this, "handleWheel", (event)=>{
            var _a, _b;
            event.preventDefault();
            const node = this.readerRef.current;
            if (!node) return;
            if (event.deltaY > 0) {
                (_a = node.nextPage) == null ? void 0 : _a.call(node);
            } else if (event.deltaY < 0) {
                (_b = node.prevPage) == null ? void 0 : _b.call(node);
            }
        });
        // Setting up event listener in the iframe of the viewer
        __publicField(this, "attachWheelListener", ()=>{
            if (!this.readerRef.current) return;
            const rendition = this.readerRef.current.rendition;
            if (rendition) {
                rendition.hooks.content.register((contents)=>{
                    const iframeDoc = contents.window.document;
                    iframeDoc.removeEventListener("wheel", this.handleWheel);
                    iframeDoc.addEventListener("wheel", this.handleWheel, {
                        passive: false
                    });
                });
            }
        });
        //search function to find all occurence and set amount of charecters for context
        __publicField(this, "searchInBook", async (query)=>{
            var _a, _b, _c, _d, _e;
            if (!this.readerRef.current) return;
            const rendition = (_a = this.readerRef.current) == null ? void 0 : _a.rendition;
            const book = rendition == null ? void 0 : rendition.book;
            if (!book) return;
            if (!query) {
                (_c = (_b = this.props).onSearchResults) == null ? void 0 : _c.call(_b, []);
                return;
            }
            await book.ready;
            const results = [];
            const promises = [];
            book.spine.each((item)=>{
                const promise = (async ()=>{
                    try {
                        await item.load(book.load.bind(book));
                        const doc = item.document;
                        const textNodes = [];
                        const treeWalker = doc.createTreeWalker(doc, NodeFilter.SHOW_TEXT, null, false);
                        let node;
                        while(node = treeWalker.nextNode()){
                            textNodes.push(node);
                        }
                        const fullText = textNodes.map((n)=>n.textContent).join("").toLowerCase();
                        const searchQuery = query.toLowerCase();
                        let pos = fullText.indexOf(searchQuery);
                        while(pos !== -1){
                            let nodeIndex = 0;
                            let foundOffset = pos;
                            while(nodeIndex < textNodes.length){
                                const nodeText = textNodes[nodeIndex].textContent || "";
                                if (foundOffset < nodeText.length) break;
                                foundOffset -= nodeText.length;
                                nodeIndex++;
                            }
                            if (nodeIndex < textNodes.length) {
                                let range = doc.createRange();
                                try {
                                    range.setStart(textNodes[nodeIndex], foundOffset);
                                    range.setEnd(textNodes[nodeIndex], foundOffset + searchQuery.length);
                                    const cfi = item.cfiFromRange(range);
                                    const excerpt = `${fullText.substring(Math.max(0, pos - (this.props.contextLength || 15)), pos + searchQuery.length + (this.props.contextLength || 15))}`;
                                    results.push({
                                        cfi,
                                        excerpt
                                    });
                                } catch (e) {
                                    console.warn("Skipping invalid range:", e);
                                }
                            }
                            pos = fullText.indexOf(searchQuery, pos + 1);
                        }
                        item.unload();
                    } catch (error) {
                        console.error("Error searching chapter:", error);
                    }
                })();
                promises.push(promise);
            });
            await Promise.all(promises);
            if (query == this.props.searchQuery) {
                (_e = (_d = this.props).onSearchResults) == null ? void 0 : _e.call(_d, results);
            }
        });
    }
    renderToc() {
        const { toc, expandedToc } = this.state;
        const { readerStyles = ReactReaderStyle } = this.props;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
            children: [
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                    style: readerStyles.tocArea,
                    children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                        style: readerStyles.toc,
                        children: toc.map((item, i)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(TocItem, {
                                data: item,
                                setLocation: this.setLocation,
                                styles: readerStyles.tocAreaButton
                            }, i))
                    })
                }),
                expandedToc && /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                    style: readerStyles.tocBackground,
                    onClick: this.toggleToc
                })
            ]
        });
    }
    renderTocToggle() {
        const { expandedToc } = this.state;
        const { readerStyles = ReactReaderStyle } = this.props;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("button", {
            style: Object.assign({}, readerStyles.tocButton, expandedToc ? readerStyles.tocButtonExpanded : {}),
            onClick: this.toggleToc,
            children: [
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
                    style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBarTop)
                }),
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("span", {
                    style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBottom)
                })
            ]
        });
    }
    //Actions to perform when the component updates
    componentDidUpdate(prevProps) {
        if (prevProps.searchQuery !== this.props.searchQuery) {
            this.searchInBook(this.props.searchQuery);
        }
        if (this.props.pageTurnOnScroll === true) {
            this.attachWheelListener();
        }
    }
    render() {
        const { title, showToc = true, loadingView, errorView, readerStyles = ReactReaderStyle, locationChanged, swipeable, epubViewStyles, isRTL = false, pageTurnOnScroll = false, searchQuery, contextLength, ...props } = this.props;
        const { toc, expandedToc } = this.state;
        return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
            style: readerStyles.container,
            children: [
                /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
                    style: Object.assign({}, readerStyles.readerArea, expandedToc ? readerStyles.containerExpanded : {}),
                    children: [
                        showToc && this.renderTocToggle(),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                            style: readerStyles.titleArea,
                            children: title
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(SwipeWrapper, {
                            swipeProps: {
                                onSwiped: (eventData)=>{
                                    const { dir } = eventData;
                                    if (dir === "Left") {
                                        isRTL ? this.prev() : this.next();
                                    }
                                    if (dir === "Right") {
                                        isRTL ? this.next() : this.prev();
                                    }
                                },
                                onTouchStartOrOnMouseDown: ({ event })=>event.preventDefault(),
                                touchEventOptions: {
                                    passive: false
                                },
                                preventScrollOnSwipe: true,
                                trackMouse: true
                            },
                            children: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsxs"])("div", {
                                style: readerStyles.reader,
                                children: [
                                    /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])(EpubView, {
                                        ref: this.readerRef,
                                        loadingView: loadingView === void 0 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                                            style: readerStyles.loadingView,
                                            children: "Loadingâ€¦"
                                        }) : loadingView,
                                        errorView: errorView === void 0 ? /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                                            style: readerStyles.errorView,
                                            children: "Error loading book"
                                        }) : errorView,
                                        epubViewStyles,
                                        ...props,
                                        tocChanged: this.onTocChange,
                                        locationChanged
                                    }),
                                    swipeable && /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("div", {
                                        style: readerStyles.swipeWrapper
                                    })
                                ]
                            })
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("button", {
                            style: Object.assign({}, readerStyles.arrow, readerStyles.prev),
                            onClick: isRTL ? this.next : this.prev,
                            children: "â€¹"
                        }),
                        /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$vendored$2f$ssr$2f$react$2d$jsx$2d$runtime$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["jsx"])("button", {
                            style: Object.assign({}, readerStyles.arrow, readerStyles.next),
                            onClick: isRTL ? this.prev : this.next,
                            children: "â€º"
                        })
                    ]
                }),
                showToc && toc && this.renderToc()
            ]
        });
    }
}
;
 //# sourceMappingURL=react-reader.es.js.map
}),
];

//# sourceMappingURL=node_modules_b97983d8._.js.map